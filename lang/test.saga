
let hof = \f -> f 1!

let i
    : Int -> Bool -> String 
    = \a b -> "hello"

let obj
    : { method: Int -> Int
      , foo: 
        { bar: Int 
        } 
      }
    = { method: \x -> x + 1 
      , foo: { bar: 0 }
      }


let fn
    : a -> Int
    = \x -> x 

let field = obj.foo.bar
let path = .foo.bar

let result = (get ob!.method) 1!

let next
    = update (.foo.bar) (\n -> n + 1) obj!

let modified
    = modify (.foo.bar) (\n -> n + 1) obj!



data MyType
  = Foo: Int
  | Bar: String -> Bool
  | Baz: \a => custom -> a
  where custom = String


type TypeFn = \a => { val: a }
type Foo = TypeFn Int!

type GenericType = \f => f Foo!
type TyBindings = foo -> Int
  where foo = String


type Functor
  :: (Type -> Type) -> Protocol 
  = \f => 
    { map: \a b => (a -> b) -> f a! -> f b! }



let listFunctorImpl
  : impl Functor: List
  = { map: \f fa -> someDummyImpl f fa!}



let fmap
  : \f a b => (a -> b) -> f a! -> f b! where f implements Functor
  = \f fa -> match fa
      | []          -> fa
      | [x | rest]  -> f x! |> prepend (fmap f rest!)!
                      


let overload
    : \f a => 
    | One: Int    -> (Tag: String ) -> f Int!    
    | Two: Bool   -> a              -> f String! 
    | Foo: String -> a              -> f Bool!   
    | Bar: Int    -> Int            -> f Int!    
    
    where f implements Functor
        , a implements Show
    
    = \fn -> match fn
        | One: i str -> of <| length str! + i
        | Two: b a   -> of <|
            if b then show a!
            else "None!"
        | Foo: str a -> of <| str ++ show a!
        | Bar: i j   -> of <| i + j



type Union =
  | \a => Foo: { stuff: a }
  | Bar: String
  | Baz 
  

