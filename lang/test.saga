



type GenericType = \f => f Int!
type TyBindings = foo -> Int
  where foo = String


let hof = \f -> f 1!

let i
    : Int -> Bool -> String 
    = \a b -> "hello"

let obj
    : { method: Int -> Int
      , foo: 
        { bar: Int 
        } 
      }
    = { method: \x -> x + 1 
      , foo: { bar: 0 }
      }


let fn
    : a -> Int
    = \x -> x 

let field = obj.foo.bar
let path = .foo.bar

let result = (get ob!.method) 1!

let next
    = update (.foo.bar) (\n -> n + 1) obj!

let modified
    = modify (.foo.bar) (\n -> n + 1) obj!


/*
type Union =
  | \a => Foo: { stuff: a }
  | Bar: String
  | Baz 
*/
  

data MyType
  = Foo: Int
  | Bar: String -> Bool
  | Baz: \a => custom -> a
  
  where custom = String




