
/*

let overload
    : \f a => 
    | One: Int    -> (Tag: String ) -> f Int!    
    | Two: Bool   -> a              -> f String! 
    | Foo: String -> a              -> f Bool!   
    | Bar: Int    -> Int            -> f Int!    
    
    where 
        f implements Functor
  
    
    = \fn -> match fn
        | One: i str -> of <| length str! + i
        | Two: b a   -> of <|
            if b then show a!
            else "None!"
        | Foo: str a -> of <| str ++ show a!
        | Bar: i j   -> of <| i + j

let ty
    : a -> b
        where 
            a = Int,
            b = a
    = foo

type Union =
  | \a => Foo: { stuff: a }
  | Bar: String
  | Baz 

  

let try
  : String -> Promise Int!
    where Promise implements Monad
  = \url -> { 
        val1 <- fetch url!
        val2 <- fetch url!
        return val1 + val2
      }



let listFunctorImpl
  : impl Functor: List
  = { map: \f fa -> someDummyImpl f fa!}



let fmap
  : \f a b => (a -> b) -> f a! -> f b! where f implements Functor
  = \f fa -> match fa
      | a  -> fa
      | b  -> f x! |> prepend (fmap f rest!)!
                  
        match b
            | [] -> on 
            | Tagged: {foo: 1, bar: [fst | rest ]} -> on
            | Foo: Int: x -> x + 1


let try
    : String -> Promise Int!
    = \url -> { 
        val1 <- fetch url!
        val2 <- fetch url!
        return val1 + val2
    }

let foo = 
    { x: 1
    , y: 2 
    }



data MyType
  = Foo: Int
  | Bar: String -> Bool
  | Baz: \a => custom -> a
  where custom = String

let proc
    : String -> Promise Int!
    = \a -> {
        b d <- bar
        b d <- bar
        match a
            | 1 -> a
            | [] -> on 
            | Tagged: {foo: 1, bar: [fst | rest ]} -> on
            | Foo: Int: x -> x + 1
        other
        foo    
    }
  

let fn
    : Data Int -> Int -> Int
    = \(Data: one) two -> one + two





let fn
    : Int -> Int -> Int
    = \one two -> one + two


  
type Functor
  :: (Type -> Type) -> Protocol 
  = \f => 
    { map: \a b => (a -> b) -> f a! -> f b! }

let listFunctorImpl
  : impl Functor: List
  = { map: \f fa -> match fa
        | [] -> fa
        | [e | fa'] -> f e ++ map f fa'
    }


let testMatch
  : List Int
  = \x -> match x
    | 1     -> "hello"
    | []    -> 0
    | [one] -> 1 


let listFunctorImpl
  : impl Functor: List
  = { map: map'}
    where 
      map' = \f fa -> match fa
        | [] -> fa
        | [e | fa'] -> f e ++ map' f fa'

let recursive
  : Int -> Int
  = \x -> {
    let sum = \y -> match y
      | 1 -> 1
      | v -> v + sum (v - 1)

    return sum x
  }



\x -> {
    let sum = \y -> match y
      | 1 -> 1
      | 2 -> "Str"
      | v -> sum v

    return sum x
}


let listFunctorImpl
  : impl Functor: List
  = { map: map'}
    where 
      map' = \f fa -> match fa
        | [] -> []
        | [e | fa'] -> [f e] ++ map' f fa'
*/

let recursive
  : Int -> Int
  = \x -> {
    let sum = \y -> match y
      | 1 -> 1
      | v -> v + sum (v - 1)

    return sum x
  }
