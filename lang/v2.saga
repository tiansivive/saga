

/*
let overload
    : \f a => 
    | One: Int    -> (Tag: String ) -> f Int!    
    | Two: Bool   -> a              -> f String! 
    | Foo: String -> a              -> f Bool!   
    | Bar: Int    -> Int            -> f Int!    
    
    where 
        f implements Functor
  
    
    = \fn -> match fn
        | One: i str -> of <| length str! + i
        | Two: b a   -> of <|
            if b then show a!
            else "None!"
        | Foo: str a -> of <| str ++ show a!
        | Bar: i j   -> of <| i + j

let ty
    : a -> b
        where 
            a = Int,
            b = a
    = foo
*/


let obj = \ a -> {
    a <- b
}