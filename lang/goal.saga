module test where


let obj
    : { fn: Int -> Int }
    = { fn: \x -> x + 1 }

let a: Int = obj.fn 1!


let fn
    : a -> Int
    = \x -> x


let fn2 = fn<String> 

type HideIt = exists (Show a) => { field: Int, hidden: a } 
data HideData a = exists (Eq b) => Hide { field: a, hidden: b }

let HideDataFn
    : Type -> Type
    = \a -> exists (Eq b) => { field: a, hidden: b }


let val
    : HideDataFn <Int>
    = { field: 1, hidden: "String" }    

let extends 
    : Type -> Type -> Constraint.Subtype
    = \a b -> a |-> b

type Functor 
    : (Type -> Type) -> Constraint.Protocol
    = \f -> 
        { map: forall a b. (a -> b) -> f a -> f b
        }

protocol Functor: f where
    map: (a -> b) -> f a -> f b


let protoList = Show e => impl Functor: List  where
    map | _ [] -> []
        | f (x: xs) -> (f x) : (map f xas)


alias Second = Int
type Lift = exists f a. { of: a -> f <a> }
type Pointed = forall f, exists a. \f -> { of: a -> f <a> }
data Custom
    : (Type -> Type) 
    = Simple: Custom <Int>   
    | Product: String -> Custom <Int>
    | Forall: forall a. Custom <a> 
    | Constrained: forall a. Show a => Custom <a> 
    | Parameterized: forall a. a -> Custom <a>
    | Existential: exists a. a -> Custom <Int>
    | Complex: forall a, exists b. Show b, a |-> { id: String } => b -> (String, Int) -> Custom <a>
    | Lambda: forall f, exists a. \f -> Custom <{ of: a -> f <a> }>

type Heterogeneous = forall f, exists a. \f -> f <a>


let parVal
    : Parametric <List>
    = Const { of: x -> [x] }

// would this work?
let h:
    : exists a. a -> Heterogeneous List! <a>
    = \x -> [x]

let array
    : Lift 
    = { of: \n -> [n] } 
let v = array.of 1!

let other
    : Pointed List!
    = { of: \n -> [n] } 



let protoList = Show e => impl Functor: Either e  where
    map | _ [] -> []
        | f (x: xs) -> (f x) : (map f xas)



let tsStyle
    : forall a b c, exists f
    . (Show a, Eq b, Functor f)
    , (a |-> { foo: Int, bar: String}, b |-> HideIt, c `extends` a)
    => a -> b -> c -> f <a b c>
    = \x y z -> pure x y z!



let get
    : String -> (Type |-> Record) -> Type
    = \k r -> r.k


let mapType
    : (Type |-> Record) -> Type
    = \t -> fold (\r k -> insert k (mapped k!) r ) {} (keys t!)!
        where 
            mapped = match 
                "foo" -> Int
                k     -> get k t
       




data Either = \a b -> Left a | Right b

let e: Either a! :: Type -> Type 

import P
